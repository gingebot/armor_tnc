#!/bin/python3
from optparse import OptionParser
import socket, random, logging, os, sys
import argparse
import urllib.request
import datetime
import yaml

import traceback
from influxdb_client import InfluxDBClient
import urllib3

host = socket.gethostname()
results = []
timestamp = datetime.datetime.now().isoformat()
CONFIG_PATH = ['./', '/etc/']
CONFIG_FILE = 'armor_tnc.conf'

def return_config():

    for i in CONFIG_PATH:
        if os.path.isfile('{0}{1}'.format(i,CONFIG_FILE)):
            with open('{0}{1}'.format(i,CONFIG_FILE)) as config_file:
                config = yaml.safe_load(config_file)
                return config
    sys.exit('\nExiting, config not found, {0} must be accessible in one of the following paths: {1}\n'.format(CONFIG_FILE, CONFIG_PATH))

def configure_logging():

    global logger
    logger = logging.getLogger()
    fileHandler = logging.FileHandler(CONFIG.get('log_file'))
    logFormatter = logging.Formatter('%(asctime)s | %(levelname)s | %(name)s | %(message)s')
    fileHandler.setFormatter(logFormatter)
    logger.addHandler(fileHandler)
    if VERBOSE:
        logger.setLevel('DEBUG')
        configure_verbose()
    else:
        logger.setLevel(CONFIG.get('log_level'))

def configure_verbose():

    global logger
    logFormatter = logging.Formatter('%(asctime)s | %(levelname)s | %(name)s | %(message)s')
    console_output = logging.StreamHandler()
    console_output.setFormatter(logFormatter)
    logger.addHandler(console_output)

def socket_test(sockett,source):

    s = socket.socket()
    s.settimeout(2)
    s.bind((source, random.randint(32768, 60999)))
    try:
        s.connect(sockett)
        s.close()
        return True
    except:
        s.close()
        return False

def perform_tests():
    for x in CONFIG.get('source_ips'):
        x['public'] = return_public(x['address'])
        result_set = {}
        for i in CONFIG.get('sockets'):
            remote_socket = '{0}:{1}'.format(i['domain'],i['port'])
            result_set[remote_socket] = socket_test((i['domain'],i['port']),x['address'])
        source_results = { 'alias' : x['alias'], 'source_address' : x['address'], 'public_address' : x['public'], 'results' : result_set}
        results.append(source_results)

def print_results(results):

    print('\nHost: {}\n'.format(host))
    print('{0:<15}{1:<15}{2:<15}{3}'.format('Source IP','Address Type','Public IP','Connectivity Results'))
    for i in results:
        
        print('{0:<15}{1:<15}{2:<15}{3}'.format(i['source_address'],i['alias'],i['public_address'],i['results']))
    print()

def log_results(results):

    for i in results:
        logger.info('TEST RESULTS: HOST: {4:<5} Src: {0:<15} Type: {1:<8} Pub: {2:<15} Results: {3}'.format(i['source_address'],i['alias'],i['public_address'],i['results'], host))

def prepare_json(results):

    data = []
    for i in results:
        for key, val in i['results'].items():
            record = {
            "measurement": "tcp_connect",
            "tags": {
                "host": host,
                "domain": key,
                "addr_type": i['alias'],
                "source_ip": i['source_address'],
                "public_ip": i['public_address'],
                },
            "time": timestamp,
            "fields": {
                "Success": int(val),
                },
            }
            data.append(record)
    return data

def return_public(sourceip):

    logger.info('Resolving source IP for %s' % sourceip)
    sourceip = sourceip
    true_socket = socket.socket
    try:
        def bound_socket(*a, **k):
            sock = true_socket(*a, **k)
            sock.bind((sourceip, 0))
            return sock
        socket.socket = bound_socket
        result = urllib.request.urlopen('https://ident.me').read().decode('utf8')
    except Exception as error:
        logger.critical(error)
        result = 'NA'
    logger.info('Source IP: %s' % result)
    socket.socket = true_socket
    return result

def write_db(db_data):

    logger.info('Writing results to DB')
    logger.debug('Results: %s' % db_data)
    try:
        DB_CONFIG = CONFIG.get('database')
        url = 'http://{0}:{1}'.format(DB_CONFIG.get('db_host'), DB_CONFIG.get('db_port'))
        token = DB_CONFIG.get('db_token')
        org = DB_CONFIG.get('db_org')
        client = InfluxDBClient(url=url, token=token, org=org)
        write_api = client.write_api()
        write_api.write(DB_CONFIG.get('db_bucket'),DB_CONFIG.get('db_org'), db_data)
        write_api.close()
    except Exception as error:
        logger.critical(error)


if __name__ == '__main__':
    global VERBOSE
    global CONFIG

    CONFIG = return_config()
    urllib3.disable_warnings()
    parser = argparse.ArgumentParser(description='Check connectivity to Armor hosts via a NAT\'d IP and non NAT IP')
    parser.add_argument('-t', '--text', action='store_true', help='text output of result to stdout')
    parser.add_argument('-d', '--database', action='store_true', help='write results to database')
    parser.add_argument('-v', '--verbose', action='store_true', help='verbose logging to stdout')
    args = parser.parse_args()
    if not args.text and not args.database:
        sys.exit('\nno option provided, see --help for available options\n')

    VERBOSE = args.verbose
    configure_logging()

    perform_tests()
    log_results(results)    
    if args.text:
        print_results(results)

    if args.database:
        db_data = prepare_json(results)
        write_db(db_data)
